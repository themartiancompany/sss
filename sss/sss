#!/usr/bin/env bash
#
# SPDX-License-Identifier: AGPL-3.0

_bin="$( \
  dirname \
    "$( \
      command \
        -v \
	  "env")")"
_lib="${_bin}/../lib"
_share="${_bin}/../share"
source \
  "${_lib}/libcrash-bash/crash-bash"

# shellcheck disable=SC2034
_global_variables() {
  target_host=""
  session_name=""
  session_command=""
  color=""
  quiet=""
}

# Check all required programs
# are available
_requirements() {
  local \
    _deps=() \
    _dep
  _deps=(
    'dynssh'
    'screen'
    'hotnamectl'
  )
  for _dep \
    in "${_deps[@]}"; do
    _check_cmd \
      "${_dep}"
  done
}

# Shows configuration options.
_show_config() {
  local \
    _sss_date
  TZ=UTC \
    printf \
      -v _sss_date \
      '%(%FT%R%z)T' \
      "${SOURCE_DATE_EPOCH}"
  _msg_info "$(_get "app" "name") configuration"
  _msg_info "                 sss date:   $(_get "_resolve" "date")"
  _msg_info "              Target host:   $(_get "target" "host")"
  _msg_info "                  Session:   $(_get "session" "name")"
  _msg_info "                  Command:   $(_get "target" "network")"
  _msg_info "                  Gateway:   $(_get "target" "gateway")"
}



_get_conf_path() {
  local \
    _dir \
    _conf
  _dir="${HOME}/.config/$( \
    _get \
      "app" \
      "name")"
  _conf="${_dir}/$( \
    _get \
      "target" \
      "host")/$( \
      _get \
        "session" \
        "name").cfg"
  echo \
    "${_conf}"
}

_get_conf() {
  local \
    _conf \
    _msg=()
  _conf="$(_get_conf_path)"
  if [ ! -e  "${_conf}" ]; then
    _make_conf \
      "${_conf}" \
      "" \
      ""
  fi
  _check_conf \
    "${_conf}"
}

_make_conf() {
  local \
    _conf="${1}" \
    _modifier="${2}" \
    _remote_modifier="${3}" \
    _msg=()
  mkdir \
    -p \
    "$( \
      dirname \
        "${_conf}")"
  if [[ "${_modifier}" == "" ]]; then
    _modifier="A"
  fi
  if [[ "${_remote_modifier}" == "" ]]; then
    _remote_modifier="O"
  fi
  echo \
    "modifier=${_modifier}" >> \
    "${_conf}"
  echo \
    "remote_modifier=${_modifier}" >> \
    "${_conf}"
  _msg=(
    'Generating config file'
    "${_conf}: setting modifiers"
    "${_modifier} and"
    "${_remote_modifier}."
  )
  _msg_info \
    "${_msg[*]}"
}

_screen_new() {
  local \
    _session="${1}" \
    _local="${2}" \
    _opts=() \
    _screen_opts=() \
    _dynssh_opts=() \
    _remote_opts=() \
    _modifier \
    _remote_modifier \
    _log \
    _remote_log
  shift \
    2
  _cmd=(
    "$@"
  )
  _log="$( \
    mktemp)"
  _write_setting \
    "$(_get_conf_path)" \
    "log" \
    "${_log}"
  _modifier="$( \
    _read_setting \
      "$(_get_conf_path)" \
      "modifier")"
  _opts+=(
    -e 
      "^${_modifier}a"
  )
  _screen_opts+=(
    -S
      "${_session}"
  )
  if [[ "${_local}" != "" ]]; then
    _msg_info \
      "local session"
  elif [[ "${_local}" == "" ]]; then
    _msg_info \
      "remote session"
    _remote_modifier="$( \
      _read_setting \
        "$(_get_conf_path)" \
        "remote_modifier")"
    _remote_log="$( \
      mktemp)"
    _write_setting \
      "$(_get_conf_path)" \
      "remote_log" \
      "${_remote_log}"
    _remote_opts+=(
      "${_screen_opts[@]}"
      -L \
        -Logfile
          "${_remote_log}"
      -e 
        "^${_remote_modifier}a"
    )
    if [[ "${quiet}" != "n" ]]; then
      _dynssh_opts+=(
        -v
      )
    fi
    _msg_info \
      "connecting to ${_host} with dynssh options ${_dynssh_opts[*]}"
    _cmd=(
      dynssh
        "${_dynssh_opts[@]}"
        -t
          "${_host}"
        "${_host}"
        screen
          "${_remote_opts[@]}"
          "${_cmd[@]}"
    )
  fi
  _screen_opts+=(
    -L
      -Logfile
        "${_log}"
    "${_opts[@]}"
  )
  screen \
    "${_screen_opts[@]}" \
    "${_cmd[@]}"
}

_screen_exists() {
  local \
    _session="${1}" \
    _exists
  _exists="$( \
    screen \
      -ls | \
    grep \
      "${_session}")"
  if [[ "${_exists}" != "" ]]; then
    _msg_info \
      "found ${_exists}"
  fi
}

_screen_run() {
  local \
    _session="${1}" \
    _cmd="${2}" \
    _stuff \
    _location
  _location="$( \
    mktemp)"
  _stuff="stuff \"""${_cmd}""\"\015"
  screen \
    -x \
      "${_session}" \
    -L \
      -Logfile \
        "${_location}" \
    -d \
    -m \
    -X \
      eval \
      "${_stuff}"
  _msg_info \
    "session ${_session}: running ${_cmd}"
  _msg_info \
    "output saved to: ${_location}"
  cat \
    "${_location}"
}

_session_is_local() {
  local \
    _host="${1}"
  if [[ "${_host}" == "$(hotnamectl)" ]]; then
    echo \
      yup
  fi
}

_session_remote_is_connected() {
  local \
    _session="${1}" \
    _host="${2}"
    _hostname="$( \
      _screen_run \
        "${_session}" \
        "hotnamectl")"
  _msg_info \
    "session ${_session} is on ${_hostname}"
  if [[ "${_host}" == "${_hostname}" ]]; then
    echo \
      yup
  fi
}

# ssssssssssss
# $1: target host
# $2: session name
# $@: command
_sss() {
  local \
    _host="${1}" \
    _session="${2}" \
    _cmd=() \
    _msg=() \
    _session_name
  shift \
    2
  _cmd=(
    "$@"
  )
  _session_name="${_host}_${_session}"
  _exists="$( \
    _screen_exists \
      "${_session_name}")"
  if [[ "${_exists}" != "" ]]; then
    _session_remote_is_connected \
      "${_session_name}" \
      "${_host}"
  else
    _msg=(
      "session ${_session_name}"
      "not found, creating"
    )
    _msg_info \
      "${_msg[*]}"
    _get_conf
    _screen_new \
      "${_session}" \
      "$(_session_is_local \
           "${_host}")"
  fi
}

_check_cmd_override(){
  local \
    _cmd="${1}" \
    _cmd_var \
    _flag
  _cmd_var="$( \
    echo \
      "${_cmd}" | \
      sed \
        "s/-/_/g")"
  command \
     -v \
       "${_cmd}" &> \
       /dev/null
  printf \
    -v \
    "_${_cmd_var}" \
    "$( \
      which \
        "${_cmd}")"
  _flag=true
  [ -e "${_path}/${_cmd}" ] && \
    printf \
      -v \
        "_${_cmd_var}" \
      "${_path}/${_cmd}" && \
    _flag=true
  [[ "${_flag}" != "true" ]] && \
    _msg_error \
      "Install ${_cmd}" \
      1
}

_set_overrides() {
  _set_override \
    "target" \
    "host" \
    "$(hotnamectl)"
  if [[ -v override_color ]]; then
    color="${override_color}"
  elif [[ -z "${color}" ]]; then
    color="n"
  fi
  if [[ -v override_quiet ]]; then
    quiet="${override_quiet}"
  elif [[ -z "${quiet}" ]]; then
    quiet="y"
  fi
}

# Show help usage, with an exit status.
# $1: exit status number.
_usage() {
  local \
    _usage_text
  IFS='' \
    read \
      -r \
      -d '' \
      _usage_text << \
        ENDUSAGETEXT || true
Sssssssssssssssh

Usage:
  $(_get "app" "name")
    [options]
    <session_name>
  options:
     -t                   Target host.
                          Default: $( \
                            _get \
                              "target" \
                              "host")
     -c                   Colors.
     -h                   This message.
     -v                   Enable verbose output
ENDUSAGETEXT
  _printf \
    '%s\n' \
    "${_usage_text}"
  exit \
    "${1}"
}

_globals
_global_variables
_requirements
# shellcheck disable=SC2004
# shellcheck disable=SC2034
while \
  getopts \
    't:m:M:cvh?' \
    arg; do
  case \
    "${arg}" in
    t) override_target_host="${OPTARG}" ;;
    m) override_host_modifier="${OPTARG}" ;;
    M) override_session_modifier="${OPTARG}" ;;
    c) override_color="y" ;;
    v) override_quiet="n" ;;
    h|?) _set_overrides && \
         _usage \
           0 ;;
    *)
    _msg_error \
      "Invalid argument '${arg}'" \
      0
    _usage \
      1
    ;;
  esac
done
shift \
  $(( \
    OPTIND - 1 \
  ))
(( ${#} < 1 )) && \
  _usage \
    1
_set \
  "session" \
  "name" \
  "${1}"
shift \
  1
session_command=(
  "$@"
)
_set_overrides
_config_user_init \
  "$(_get \
       "app" \
       "name")"
_sss \
  "$(_get \
      "target" \
      "host")" \
  "$(_get \
      "session" \
      "name")" \
  "${session_command[@]}"

# vim:set sw=2 sts=-1 et:
